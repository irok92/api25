# Memory

In processors with operative systems, a program usually gets its own little region of memory for itself.
Usually this memory is not linearly to how the physical memory is placed.
It partitions and maps ranges to sections at a time, with a fake address known as virtual memory.
![[res/Pasted image 20251021194505.png]]
The benefits with this is that memory can easily be fragmented and even grow on demand, also having fixed virtual ranges makes it easier to build permission systems and let the OS clean up after processes closes down.

In a MCU without an OS, memory tends to be freely accessible, meaning you have to take care of the partitioning yourself.

The process memory usually is filled with:
- Machine code
- the stack. 
- the heap.

## Stack
The stack is basically all arguments, local variables and return addresses,
(memory references where to where in the code it should return to).

With virtual memory addresses, the stack can grow indefinitely, but in MCUs, this can actually be quite a problem if you overuse recursive calls and add more variables, usually called a stack overflow.

Also security wise, if you somehow write to the stack outside the range, you could overwrite the return location, and suddenly it can run code that wasn't intended.

An OS usually swaps the "Stack pointer" to swap between programs, and as a user you can also swap stacks to swap "threads" of execution, known as green threads and/or coroutines.
## Heap

The heap is usually memory that can be of any size, and can be freed at any point.
Getting memory is not always guaranteed, but you usually just crash if critical memory is not found.

The heap usually is more secure for storing dynamically sized data, and also somehow is allowed to be shared between processes if you told the OS to.

In Modern CISC systems, sometimes memory can be accessed independently by other components in your system, like the Storage, GPU, NPUs (AI), network card to let them do the extra processing, known as ReBAR (Resizable BAR). almost crucial for modern games to process data.

The memory model for heap is actually free to alter as you want.
You could simply as the OS to map memory for your process and you can segment it how you want and write your own allocators.

## Pipes

Pipes can be seen as binary streams of inputs and outputs of a program, they exist in Linux and Windows.
There is the default ones:
 - stdout - Often the "output" of a program, any useable information, don't confuse this with logging.
 - stderr - Often the output for logging information, this is usually what a console shows.
 - stdin - This is a buffer that other programs can hook into to send thier own information.
You can via OS APIs, create your own pipes to subprocesses to talk with them.
Usually when reading and sending things between pipes, an OS can rather than storing the information, simply switch between programs to skip the whole communication part.
This part usually doesnt exist in MCUs that dont run a OS, but its good to know.

## Environment Variables

Each program before it starts gets passed a list of key/value pairs called Environment Variables.
These tend to be useful for predefined locations, whole system wide configuration or user specific information.