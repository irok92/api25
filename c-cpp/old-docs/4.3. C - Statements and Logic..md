
#### Math operators

```c
a + b // addition
a - b // subtraction
a * b // multiplication
a / b // division
a % b // Modulus / rest operator, useful when you want a value to loop around a fixed room.

-a // inversion operator.
a++ // increases value by one
a-- // decreases value by one.
--a // When in an expression, this will decrease the order first 
++b // When in an expression, this will increase the value first.

a += b // add to itself with b
a -= b // subtract to itself with b
a *= b // multiplies itself with b
a /= b // divides itself with b
a %= b // modulus on itself with b.

```

### Bitwise operators

Bitwise operators are often used to compress bits into existing types, or match sets of true and false values.
It can also be used for some encryption algorithms or hashing (a numberic sum to represent a string.)
It will compare the bits of each position and return a value of each position.

#### Bitwise NOT

Its pretty simple, it turns all 0 to 1 and 1 to 0, flips them.
```c
~A
```

| Var | 7     | 6   | 5   | 4   | 3   | 2     | 1   | 0     |     |
| --- | ----- | --- | --- | --- | --- | ----- | --- | ----- | --- |
| A   | **1** | 0   | 1   | 0   | 0   | **1** | 0   | **1** |     |
| Out | 0     | 1   | 0   | 1   | 1   | 0     | 1   | 0     |     |

#### Bitwise AND

With bitwise-AND, the output will be a 1 if A and B is 1.
```c
A & B
```

| Var   | 7     | 6   | 5   | 4   | 3   | 2     | 1   | 0     |     |
| ----- | ----- | --- | --- | --- | --- | ----- | --- | ----- | --- |
| A     | **1** | 0   | 1   | 0   | 0   | **1** | 0   | **1** |     |
| B     | **1** | 1   | 0   | 0   | 0   | **1** | 0   | **1** |     |
| A & B | **1** | 0   | 0   | 0   | 0   | **1** | 0   | **1** |     |

#### Bitwise OR

Bitwise-OR will return 1 if either A or B is 1
```c
A | B
```

| Var    | 7     | 6     | 5     | 4   | 3   | 2     | 1   | 0     |
| ------ | ----- | ----- | ----- | --- | --- | ----- | --- | ----- |
| A      | **1** | 0     | **1** | 0   | 0   | **1** | 0   | **1** |
| B      | **1** | **1** | 0     | 0   | 0   | **1** | 0   | **1** |
| A \| B | **1** | **1** | **1** | 0   | 0   | **1** | 0   | **1** |
#### Bitwise XOR

The exclusive-or will only return 1 if only one of A or B is set to 1.
```c
A ^ B
```

| Var   | 7     | 6     | 5     | 4   | 3   | 2     | 1   | 0     |
| ----- | ----- | ----- | ----- | --- | --- | ----- | --- | ----- |
| A     | **1** | 0     | **1** | 0   | 0   | **1** | 0   | **1** |
| B     | **1** | **1** | 0     | 0   | 0   | **1** | 0   | **1** |
| A ^ B | 0     | 1     | 1     | 0   | 0   | 0     | 0   | 0     |

####  Bit-Shifting operators
The shifting operator usually takes a binary number and pushes it a number of positions left or right.
Left is like adding a 0 to a number.
Right is like removing a 0 to a number.
The overflowing bits are removed and the extra bits get set to 0.

```c
A << 2
// or
A >> 2
```

| Var    | 7     | 6   | 5     | 4   | 3   | 2     | 1   | 0     |
| ------ | ----- | --- | ----- | --- | --- | ----- | --- | ----- |
| A      | **1** | 0   | **1** | 0   | 0   | **1** | 0   | **1** |
| Pos    | 5     | 4   | 3     | 2   | 1   | 0     |     |       |
| A << 2 | 1     | 0   | 0     | 1   | 0   | 1     | 0   | 0     |

#### Assignments
All of these bit operators have a self-assigning version
```c
A <<= 2
A >>= 2
A &= B
A |= B
A ^= B
```

#### Sidenote

There are alot of other bitwise operators that are just function calls that might have thier uses, they might be dependant on the compiler, but they are good to know about.

**popcount** - return a count of all set bits in a number.
**rotate left/right** - Like left or right shift, but the overflow replaces the underflow, so no bits are lost, only shuffles left and right.
there are shifts where the overflow is set to 1 or 0

### Logical Operators

Often used in if statements, but also used to chain logic.
Logical operators actually prevents execution of code of statements that arent matching.

Logical AND
```c
A && B
```

If A is a function call return false, B will not execute.

Logical OR
```c
A || B
```
If A is true, B will not execute.

NOT operator
```c
!A
```
Simply inverses the boolean statement.


### If Statements
```c
if (a) 
	expression();
else
	expression();
```

```c	
if (a)
	expression();
else if(b)
	expression();
else
	expression();
```

```c
if (a) { // Pushes a stack frame.
	int var = 1;
	expression();
} else if(b) {
	expresion();
} else {
	expression();
}
```

### While loops
```c
// Loops while expression is true.
while(e) {
	break; // Stops loop
}
```

```c
// Loops while expression is true, will skip if expression is false at start.
while(e) {
	continue; // Stops loop
	some_statement_it_skips();
}
```
Return statements work well in loops.
```c
while(e) {
	return 10;
}
```

Sometimes you can see patterns where you have a function that counts down and it does nothing, it simply acts as a blocker or timer.
```c
while(count_down());
```

#### Do-while loops
```c
// Runs the loop at least once before checking when to continue.
do {
	break;
	continue;
	return;
	// break and continue works here as well.
} while(a);
```

#### For loops
An more common pattern for loops where you can define variables, conditions and a iteration step in the same step.
```c
int sum = 0;
// Normally you use < size to loop from 0 to 9, even if an array is 10 of a size.
for(int a = 0; a < 10; i++) {
	sum += a;
	break;
	continue; // works the same here.
}

// You can leave any fields empty inside a for loop by just adding a ; to separate it.
int a = 0;
for(; a < 10; a++) {}

// can make it act as a while/infinite loop if you want and break with if statements.
int  a= 0;
for(;;) {
	a += 10;
	if (a > 200) {
		break;
	}
}

```


#### Switch-Case

Switch cases  were a loop, some languages has them as some kind of if statements.
They are most suitable to be used with enums, the thing you test the cases against is usually some integer or char type.
```c
int a = b;
switch(a) {
// multiple ones in sequene makes them all match.
case 1:
case 2:
case 3:
	 expression();
	 expression();
	break; // Its a loop, without break, it would actually continue to the next statement.
case 4: {
	int a = 10;
} break;
case MY_ENUM: {
} break;	
default: // Like an "Else for switch statements".
	break; // If this break wasnt here, it would go back to the top and loop around again.
}
```

Continuation of the Union example
```c
struct MessageDataA { int a; int b; };
struct MessageDataB { float b; float c; };
struct MessageDataC { double d, char b; };

union MessageData {
	struct MessageTypeA a;
	struct MessageTypeB b;
	struct MessageTypeC c;
};

enum MessageType { MESSAGE_TYPE_A, MESSAGE_TYPE_B, MESSAGE_TYPE_C };

struct Message {
	MessageType type;
	MessageData data;
};


void HandleMessage(struct Message* message) {
	switch(message->type) {
		case MESSAGE_TYPE_A:
			HandleMessageTypeA(message->data.a);
			break;
		case MESSAGE_TYPE_B:
			HandleMessageTypeB(message->data.b);
			break;
		case MESSAGE_TYPE_C:
			HandleMessageTypeC(message->data.c);
			break;
		default:
			HandleUnknownMessage(message);
			break;
	}
}
```

#### Labels

Labels are very powerful, since it basically allow to jump anywhere you want in the code.
However, it also makes it very unpredictable and dangerous, so its concidered bad practice, in most cases, you can use a if or some thing to jump properly.
Labels are positional markers, so they are just skipped over and will continue through them if no goto is called.

```c

void my_function() {
	int i = 0;
start_of_loop:
	i += 1;
	do_stuff();
	if(a > 10)
		goto stop;
	goto start_of_loop;
stop:
	do_end_stuff();
}

```

Labels emulate quite alot of how Assembly handles its logics with the flat parts.
An important notion is that if you are gonna use labels, always define you variables before any labels are introduced or jumped in.
Don't store extra variables inside if statements or loops within the labels, otherwise it can corrupt the stack.

One common use for labels in other languages which sort of allows labels to break out of loops that are nested.
```c
for(int x = 0; x < 10; x++) {
	for(int y = 0; y < 10; y++) {
		goto end_of_all_loops;
	}
}
end_of_all_loops:
do_end_stuff();
```

(This is javascript, yes they look very similar)
In javascript, they have put "labels" on the loops directly instead, where you can call break with a label to choose where to break from.
```js
let i, j;

loop1: for (i = 0; i < 3; i++) {
  loop2: for (j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break loop1;
    }
    console.log(`i = ${i}, j = ${j}`);
  }
}

```

Labels in C is however more powerful because they can be anywhere. but you can make very wierd logic this way.


#### Variadic Arguments

functions do actually have the ability to have flexible arguments, they are called variadic arguments and usually is defined like:

```c

#include <varargs.h>

void my_function(my_fixed_type arg1, ...) {
	va_list args; // va_list can be passed around to other functions, its what holds the arguments.
	va_start(args); // Starts reading the arguments.
	int a = va_arg(args, int); // reads one arguments, queues next.
	double b = va_arg(args, double); // reads another arg.
	va_end(args); // closes the end.
}


```
Normally its not as performant because you have to branch types, but its mostly useful for printing
#### Print / Formatting

Printf is a variadic function which is sort of compile time optimized since its used to often.
```c
#include <stdio.h>

void print_stuff() {
	printf("Hello, %s! How are you doing with %s?", "John", "programming")
}
```
Most formatting of strings uses a pattern where you have % with a letter that represents a type.

Here are some examples from the cppreference website:
```c
const char* s = "Hello";
printf("Strings:\n"); // same as puts("Strings");
printf(" padding:\n");
printf("\t[%10s]\n", s);
printf("\t[%-10s]\n", s);
printf("\t[%*s]\n", 10, s);
printf(" truncating:\n");
printf("\t%.4s\n", s);
printf("\t%.*s\n", 3, s);

printf("Characters:\t%c %%\n", 'A');

printf("Integers:\n");
printf("\tDecimal:\t%i %d %.6i %i %.0i %+i %i\n",
					 1, 2,   3, 0,   0,  4,-4);
printf("\tHexadecimal:\t%x %x %X %#x\n", 5, 10, 10, 6);
printf("\tOctal:\t\t%o %#o %#o\n", 10, 10, 4);

printf("Floating-point:\n");
printf("\tRounding:\t%f %.0f %.32f\n", 1.5, 1.5, 1.3);
printf("\tPadding:\t%05.2f %.2f %5.2f\n", 1.5, 1.5, 1.5);
printf("\tScientific:\t%E %e\n", 1.5, 1.5);
printf("\tHexadecimal:\t%a %A\n", 1.5, 1.5);
printf("\tSpecial values:\t0/0=%g 1/0=%g\n", 0.0 / 0.0, 1.0 / 0.0);

printf("Fixed-width types:\n");
printf("\tLargest 32-bit value is %" PRIu32 " or %#" PRIx32 "\n", UINT32_MAX, UINT32_MAX );
```

Refering back to pipes in 3. Programs, in code. C has a few default communication channels that allows it to talk between processes.
Usually any kind of buffer that streams information is called a FILE, in the C standard library.
```c
fprintf(stderr, "MyMessage %s", "Messages"); // File print formated.
sprintf(string_buffer, "MyMessage %s", "Message") // Print to a string buffer.
```

Theres been some safety concerns with formatting to buffers if its oversized, so in later versions they made versions where you can provide a max size of your buffers to prevent overflows.
```c
snprintf_s(string_buffer, max_string_size, "Message %s", "")
```

There is alot of different variants of the print functions its best to look into https://en.cppreference.com/w/c/io.html how to handle file reading and so on.

