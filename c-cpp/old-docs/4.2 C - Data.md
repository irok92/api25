
## Variables
Variables in C is defined with a type and a value.
```c
my_type my_var;
```
You can also assign a starting value:
```c
my_type my_var = 10;
```

In very old versions of C (Before C99), you couldnt even assign a starting value to.
A problem that can arise is that memory that is defined but not assigned, can have junk data from a previous call.
There is a small cost to zero-ing data, but is a good pratice.

## Data types

In C, All types can be constant, unmutable, but they are mutable by default.
```
const my_type my_variable;
```

#### Booleans
There isn't actually a boolean type in C until a later version known as C23
people can usually define thier own boolean type with "typedef".
Or you can `#include <stdbool.h>`
Normally its just int or a char that is 0 or 1 based on the logical statement.
#### Integers:

```c
// These can actually vary in size based on the CPU arcitecture alot, especially in MCUs like arduino uno.
char my_var = 0 // Usually 8-bit
char my_var = '3' // Save a single character.
short my_var = -12314; // usually 16 bit
int my_var = -12310; // usually 32 bit, can be 16.
long my_var = 123141L;// usually 32 bit as well, but minimal 32 bit.
long long my_var = 1231401230123LL;// minimal 64 bit.

// Unsigned versions.
unsigned char
unsigned short
unsigned int my_var = 123141U;
unsigned long my_var = 123141UL;
unsigned long long  my_var = 123141ULL;

// using standard library.
#include <inttypes.h>
// Regular signed integers, size guarenteed.
int8_t
int16_t
int32_t
int64_t

// Regular unsigned integers, size guarenteed.
uint8_t
uint16_t
uint32_t
uint64_t

// Unsigned integer, is the same size an an address (32 bit in 32bit systems, 64bits in 64bit systems.)
size_t
wchar_t // Unicode character.
```

#### Floating-points:
Anything with decimal points is known as floating points:
```c
float // 32 bit usually
double // 64 bit precision
long double // 80 or 128 bits very rarely used and might be incompatible.
```
They usually divide a segment for the exponent of the value, and the rest as the value, it varies per architecture sometimes but they try to have a standard known IEEE 754 for most CISC and modern processors.

#### Type Casting

To convert between types, you surround it with parenteses before the value you want to convert.
```c
float x = (float) 100ULL; 
```
General rules with types is that you can loose information if converting from larger to smaller types. so you must be aware of it when doing math expressions.

You cannot convert constant types to mutable types as they are expected to be immutable.
But a mutable type can be cast as a constant type.

#### Pointers
Pointers is basically what makes C very powerful, its basically a memory address slot that points to a type.
They can either point to a single address, or a range of addresses, size have to be provided separately.
```c
float*
```
Usually this indicates something located on the heap, or you wanna pass something along from the stack/local variables (However its pretty unsafe).



Constant pointers exist, meaning that the address cant be changed, but the contents can.
```c
float * const
```
A pointer to a constant value is a pointer that can be changed, but not the value.

```c
const float*
```

NULL is the indicator for an empty address
```c
float* my_var = NULL;
```

Useful for when you wanna iterate a memory space, since when doing math operators with pointers, you do it with the memory address and not its value. To get its value, you need to use a dereference.
```c
// Gets the address and stores it to a pointer.
float* my_pointer = &my_float_variables;
*my_pointer; //gets the value from the memory as a float.
*my_pointer = 10.0f; // sets the value as a float.;
*(my_pointer + 1) = 10.0f; // Sets the next value in memory. 
```

You can even have const pointer to a const value.
```c
const float* const;
```

Pointers can also be many several levels deep. In this case it could be an list of points to their own list.
```c
float** my_float;

const float* const* // a pointer to a const pointer of a constant float, yet its changable. since the right most is the current level pointer.

**my_float // dereferencing two levels back gives the actual value.
```

So another powerful aspect is that pointers to functions also exists, to allow swapping out functionality as you want. There are many safety hazards to this as well tho, so normally you only point to your own functions. or if neccessary a DLL. since this swaps where you execute code basically.
```c
// if no name provided;
int (*)(arg_type1, arg_type2);
// With variable name or struct member name.
int (*my_func_pointer)(arg_type arg1, arg_type2 arg2) = &my_function;

if(my_func) { // Check if it exists.
	my_func(1, 2); // You can call it.
}
```

When doing arithmetics with pointers, an important aspect is to think of the size of the type when you add to it.
```c
double* a;
a + 1 //(1 will jump by the size of a double).
```

Void pointers are basically unknown segments of memory without a type.
These usually are used to pass around between libraries or just allows you to fully embrace the freedom of type reading.
```c
void*
```

An example for reading a buffer freely is like this:
If you are converting the pointer between types of different sizes and wanna read them byte for byte, its best to use char* or void* as the base pointer.

```c
void* my_byte_array = &my_buffer; // Will always increment with a byte.
double my_double = *((double*) my_byte_array); // Casting to a double* and the deref for the value.
my_byte_array += sizeof(double); // Move forward from the double and deref

float my_float = *((float*) my_byte_array); // convert to float* and deref
my_byte_array += sizeof(float); // Move forward from the float.

short my_short = *((short*) my_byte_array); // convert to short* and deref
my_byte_array += sizeof(short); // Move forward from the short.
```


#### Arrays

Arrays usually are fixed sized in C.
In some languages, arrays can be stored in the heap.
However in C and C++, arrays are a quantity of the same variable and lives in the same space as its defined

```c
int my_array[3] = {1, 2, 3};
float my_array_2d[3][3]= { {1, 2, 3}, {1, 2, 3}, {1, 2, 3} };
```
The array size usually must be known at compile time. for it to have proper alignment.

Accessing 
```c
int my_array[3] = {10, 20, 40};
my_array[0] = 10;
my_array[1] = 5;
my_array[4] = 4; // will go outside array, doesn't give error!
```
When referring to arrays directly, they tend to act as pointers.
```c
int my_array[3] = {10, 20, 30};
int my_value = *(my_array + 1);
int my_value = *(my_array + 4); // will go outside array, doesnt give error!
```

Keeping within bounds can sometimes be scary, you can however get the size of the array:
```c
sizeof(my_array) // gives the whole arrays size in bytes
sizeof(my_array[0]) // gives a single elements size in bytes.
sizeof(my_array) / sizeof(my_array[0]) // gives element count.
```

There are extensions that compilers add to the language, for data of dynamic lengths in the stack and structs, but they do often count as bad practices, due to stacks can easily be corrupted.
They are usually known as VLA / VLS (variable length array / structs).

```c
int my_func(void) {
	int a = 40;
	int array[a] = {}; // Cannot assign values when dynamic must, be filled manually.
	array[0] = 30;
}
```

#### Strings

Strings in C, actually return a `char*` or a `wchar_t*` Unicode (16-bit characters) to an (null terminated array), arrays that stop at 0.
They are usually closed of with 0 or '\0' in memory, even a empty string is at least 1 size wide
```c
const char* my_string = "Hello World!";
//
const char* my_string = ""; // ends with \0.
// Splitting it into characters, with closing \0.
const char* my_string = {'a', 'b', 'a' + 2, 'd', '\0'};
// Stacking strings in sequence merges them., works with macros as well.
const char* multi_string = "Hello\n" "World\n" "And somethingmore\n";
```

If you want to store strings without the heap or in structs, you can use fixed sized buffer.
```c
// Just make sure the last character is a 0.
char my_string[64] = "hello";
```

#### Allocation and Deallocation

To get things placed on the heap, C has some standard functions that the OS provides.
```c
int count = 435;
// Malloc simply gets a segment of memory that can be any data.
int* int_array = (int*) malloc(sizeof(int) * count);
// Calloc allocates and and sets all data to 0.
int* cleared_int_array = (int*) calloc(count, sizeof(int));

// Will release the memory from the heap.
free(int_array);
free(cleared_int_array);
// notice, that int_array and cleared_int_array still can be used.
// Some security vurnabilities can occur due to people replacing pointers after they have need freed somehow, known as "Use after free"

// Will find a new location with a new size, frees the old one.
int* resized_int_array = realloc(int_array, sizeof(int) * (count + count))


```
#### Structs

Structs are your own types, plain and simple. they have not values assigned. 
They have a fixed size, but you can put structs in infinite chains to emulate.

```c
struct MyType {
	int a;
	int b;
	int c;
	float a,b,c,d;
	MyOtherType b;
}; // yes, a ; is needed at the end.
```


Accessing members is as simple as using .
```c
my_struct_var.a
```

If a struct is a pointer you have to deference it to access it.
```c
(*my_struct_var).a
```
You do have a bit of syntax sugar to it with the arrow operator.
```c
my_struct_var->a
```
Gives you a visual indicator that its a pointer you are trying to access.

You can define structs without names as well, if you are using it directly in a variable.
```c
struct {
	int a;
	int b;
	int c[4];
} my_variable = {0}; // Here ; allows you to define it as a variable.
```

Useful if you wanna put structs in structs like folders.
```c
struct {
 struct {
	 int gamma[4];
 } beta;
} alpha;
alpha.beta.gamma[1];
```


To assign a value in structs in C is alot more flexible than C due to its independance on order and initial value, there is no constructors.

```c
struct A {
  int a;
  int b;
  int c[3];
  struct {
	int x;
  } d[4];
};

// a bit odd to have "struct A" as a type, but we will get to it after this with "typedef"
// You can practically set values in structs in any order you want.
struct A i = { 10, 10, {1,2,3} }; // in order, doesnt need names
struct A j = { .b = 10, .a = 10, .c = {1,2,3} }; // out of order requires names.
struct A k = { .a = 10, .b = 10, .c[0] = 0, .c[1] = 10, .d[0] = { .x = 10 } };
struct A l = { 10, 10, 
  .c = { [0] = 1 , [1] = 2 },
  .d = { [0] = .{ .x = 10 }, [1] = .{ .x = 20 } } 
};
```

If you needs to send a struct inside an argument you can use the following syntax.
Its basically is just a type casting followed by an assignment block.

```c
my_function((struct MyStruct){ ...values });
// or if its the argument is a pointer, you can send the address, 
// (used to make it faster, since you only pass a stack pointer, usually a const one.)
my_function(&(struct MyStruct){ ... values });
```

Bitfields are an extension of structs that allows you to specify how many bits the fields should take:
```c
// Space optimized representation of the date
struct date {
    // d has value between 0 and 31, so 5 bits
    // are sufficient
    int d : 5;

    // m has value between 0 and 15, so 4 bits
    // are sufficient
    int m : 4;

    int y;
};
```

They will try to compress into each other in sequence to save space.
#### Typedefs

You can define types as an identifier, using the typedef keywords.
```c
typedef float meters_per_second;
typedef float vec3[3]; // Array of 3 floats.
typedef struct MyStruct { // requires name here to be able to use struct MyStruct;
	int a;
} MyStruct; // allows to use only MyStruct instead of MyStruct;
typedef struct MyStruct* MyStructPtr; // pointers can be typedefed as well as a pointer. kinda hides it tho when using.
```

Normally you want define structs separately and use the type inside another struct for nesting, it makes it more compatible with C++ and also usable as a standalone in other parts of the code which might not need the top parts.

#### Enums

Enums is basically a set of named integer values of variants.
```c
// If no value is assigned, starts at 0
// A starts at 0, b is 1, c is 2.
enum MyEnum { A, B, C };
```

```c
// A = 10, B = 11, C = 12, D = 20, E = 21, F = 22;
enum MyEnum { A = 10, B, C, D = 20, E, F};
```

```c
// Enums allow any vallue and math related to each other.
enum MyEnum { A = 10, B = A + 10, C = B + 30 };
```

You can lock the the Enum as a type.
```c
// All enum values are still in global scope!
// the type can be typedefed to reduce noise.
enum MyEnum a = A;
```
Enums are mostly used for flags, array field names and constants, usually people prefix it with the enum name for easier to read.
```c
typedef enum UserFlag {
   USERFLAG_IS_LOGGED_IN = 0b0001;
   USERFLAG_CAN_READ     = 0b0010;
   USERFLAG_CAN_WRITE    = 0b0100;
   USERFLAG_CAN_BREAK    = 0b1000;  
} UserFlag;
```

normally if you want to have enum of other types.

Sidenote:
You can use preprocessors or constants variables, then typedef a custom type instead.
```c
typedef char* ConfigString;
#define CONFIGSTRING_A "My String"
#define CONFIGSTRING_B "My Other String"

// Alternatively
typedef const char ConfigString[];
static ConfigString CONFIG_NAME = "Hello World"; // Static means it exist only at one place in the assembly, it will not be copied locally to a function.
```

#### Unions
Unions is the final datatype in C, it is very similar to structs, in that it can have members.

```c
union A {
	int a;
	short b;
	float c;
	double d;
};
```
However, the members all share the same memory slot, by accessing a member, you interpret it as that value.
```c
union A var = { .a = 10, .b = 30 }; // C will allow you to write .a, .b etc in sequence, but it will overwrite each other.. kinda stupid, but its basically still seen as operations to set all the information, they arent constant by default.
var.a = 10; // will read it as int
var.b = 0343; // will read it as short.
```
A union is basically a way to make it possible to have different types in the same arrays or buffers.
A union will always be the size of the largest type from a member to fit.
```c
sizeof(A) == sizeof(double)
```

A common use for unions is to make things like queue actions or command buffers, like a hub for connecting events or different styles.
They tend do combine a enum and a union inside a struct to it, since C doesnt actually store what "Type" it is. 
It only allows it to be read as a different one, the enum complements it to give it a type.

```c
// prefer to typedef it as well.
struct MessageDataA { int a; int b; };
struct MessageDataB { float b; float c; };
struct MessageDataC { double d, char b; };

union MessageData {
	struct MessageTypeA a;
	struct MessageTypeB b;
	struct MessageTypeC c;
};

enum MessageType { MESSAGE_TYPE_A, MESSAGE_TYPE_B, MESSAGE_TYPE_C };

struct Message {
	MessageType type;
	MessageData data;
};
```

Later yo can also combine it with a switch case to branch the logic of all different types.

