

C is probobally the language that is the closest to machine codes right before assembly.
- It has almost no abstraction, except for Macros
- It has no guard rails for memory access.
- All code that you write only has a single copy of itself, making it small, (except for inline functions)

The benefits of this is that you are alot more aware of your code, with just a little you can almost predict how the machine code will look like.
You are also more aware of any creations and deletions which can heavily improve performance.
But as all control comes with the modularity scope, it also comes at the cost of more development time and flexiblity to writing more detailed system.
C is best placed for single purpose libraries, drivers.
C is probobally compatible with most, if not all, language due to shared libraries (DLLs) and its simple type system.

# Modularity in Functions

Like most languages, your functions have inputs and outputs.

The arguments in C is almost always fixed sized, there is variadic arguments which we will describe later.

```c
return_type function_name(arg_type name1, arg_type2 name2, ...)
```

The deal that makes C so performant is that everything has a fixed size and is very predictable due to its simplicity.
Dynamic memory is still fixed size in arguments, since you only pass an address which is fixed at 8 bytes (64bit).

(Before optimization)
![[res/Pasted image 20251021201119.png]]


(After Optimization)
![[res/Pasted image 20251021202542.png]]

The key to most optimizations is that it can reduce machine code that can be calculated.
Like most math expression, you have variables and return values on each step in the code.
The code uses exported functions as its root for the optimzations,  basically any function accessible as a library or the main function.
Most small functions can be "inlined", meaning they are copy-pasted into the machine code when called (not always, there is thresholds for the compiler).

(after inline keyword)
![[res/Pasted image 20251021203520.png]]
It doesn't actually make the code faster, only shorter, since inline functions arent exported.

One important aspect of C is that you don't actually have to define a function implementation to use it, this allows external libraries pretty easily use it.
However optimization can only occur if the code can be predicted / seen when compiling.

Now lets get to the meat of the language.

# Headers and Source

In C. 
Header files stop with ".h"
source file stop with ".c"

When compiling C, there is 3 steps to the process:
- Preprocessing - A pre-stage to parsing where you can "script" what code to read, usually visible with "#" at the start of the line.
- Parsing - Aka reading the file, finds syntax errors
- Compiling - Translating into near machine code, finds code errors.
- Linking - Combining the locations of all functions and data into a final assembly / executable / library, will give errors about missing references and conflicts.

### Source Files

In the parsing and compiling stage, all C files actually isolated, they cannot see any other function from another file, unless you manually defined it.
Definition order in C actually matter, to circumvent this, C uses a concept known as header files.
So because C files are isolated, they can be compiled in parallel by your program.
Also any "compiled" file can be reused later in the linking process, known as object files, this is usually handed by build systems like CMake, Make, Ninja etc to optimize build times when recompiling.
C is really fast to compile compared to C++ due to its simplicity.
### Headers
A header usually is a separate file that contains only what you need to see.
They are written like this in C files and in other header files for more dependencies.
```c
#include "myheader.h"
```
The root folders for where your header will look at is called include directories.
You can define multiple of them and it will pick the ones based on order of definition.
The OS usually has thier own include directories, but they use `<...>` often to begin looking at those folder, it will still try to use your own include folders if it doesn't find anything.
```c
#include <inttypes.h>
```

So headers usually contains any functions or structures without bodies are called prototypes and sometimes inline functions as well, anything that is shared between.
```c
int square(int num);
```
This of course also is order-dependent if you are using your own types in a prototype.
```c
typedef int my_int_type;
int square(my_int_type num);
```

If you have structures, you don't have to define them if they are pointers/addresses.
```c
struct my_struct;
int square(my_struct* s);
```

But as soon as you need to know the size of a type which you don't, you will get an error.
So normally you save hidden information in struct pointers, then just store the structs inside your c file.
There are practices to make header order management easier which i can show later when getting to preprocessors.

### Preprocessors
A important part of C and C++ is called preprocessors.
Its basically.. logical statements for what code to read. when compiling, you can add your own defines, or you could program defines in headers as variables so sort of isolate out compatibility code, or specific unwanted code specifically for debugging, or just if you want to make macros to "write" code blocks shorter.

The most common pattern for preprocessors is called include guards, it basically makes sure that if you include a header multiple times anywhere in the other headers, it will be skipped.

```c
#ifndef MY_FILE_H
#define MY_FILE_H
 int my_code_here();

#endif // MY_FILE
```
Since this is run per source file, the first line, checks if a "Define" is not set, then defines it. and closes of where it wants to stop pasting the code.
Basically turning it to a one time only paste, since the define exists.
Preprocessors are very powerful, but require a recompile of almost all code since it almost impossible to predict what's changed. 
This of course is per project, you can split things into your own static library (Basically just a bunch of object files as mentioned above)

# Shared Objects (DLL / Dynamic Linked Library)

So shared libraries are a little special, only in OSes. They are kinda thier own processes sometimes that you can get pointers to thier functions, by name, from the OS.
They are already compiled, got their functions ready and you can either link to them via your code directly or obtain them via OS-calls. Its often the fundemental thing that communicates with other programs in your OS. 
They also are much cheaper regarding compile time.
However if you provide DLL files for your application, its also a security issues, since people can easily replace your DLL with thier own. since they are linked when the application starts, people can override the file or add a different directory and so on.
