
#### Some C features that look different in C++

Typedef by default, no need to typedef structs, enums and unions in C++
```cpp
struct A {};
A a;
```


Struct assignment
```cpp

struct MyStruct { int a, b, c; int d[4]; };
// C
// Can be without the parenteses.
MyStruct a = (MyStruct) { .a = 10, .b = 30, .c = 10 };

// C++
// No parenteses needed to define a struct, older c++ could only assign with positional.
MyStruct a = MyStruct { 1, 2, 3 };

// You can also write for initializing a struct
MyStruct a =  {1, 2, 3};
// or even.
MyStruct a {1, 2, 3};

// First in C++2023 they added some partial support for the named assignment syntax, known as aggregate initialization / designated initializers.
MyStruct a = { .a = 1, .b = 30, .c =30, .d { 1, 2, 3, 4} };

// Works as well, but it must be in order!
struct MyStruct a { .a = 1, .b = 2, .c = 3, { [0] = 1, [1] = 2, [2] = 3, [3] = 5 }};
```

All values are initialized by default.
```cpp
int a; // Will always be 0.
MyStruct a; // will always be 0 or default values.
```

C++ hides away the allocations calls to be more streamlined.
```cpp
// Malloc + initialization (via constructors if provided)
MyStruct* m = new MyStruct;

// Free and cleanup (via destructors if provided)
// still needs to be called manually (But there is std::unique_ptr to make it automatic.)
delete m;

Arrays are also
MyStruct* m = new MyStruct[count];

// Deletes arrays and deconstructs (if provided)
// Still needs to be called manually, but std::unique_ptr
delete[] m;
```

## Main features of C++

The entire language specification is here.
https://en.cppreference.com/w/cpp/language.html

Some core features that existed for long.
##### [Namespaces](https://en.cppreference.com/w/cpp/language/namespace.html) - gives the ability to make "folders" of code
```cpp
namespace my_name { struct my_struct {}; }
my_name::my_struct // To Access it.
```
##### [Exceptions](https://en.cppreference.com/w/cpp/language/try.html) - Catch errors and allows you to handle them
```cpp
  try { run_code_to_check(); } 
  catch ( std::exception e ) { do_things_if_error(e.what()); }
  throw std::exception("My Exception"); // this needs to be inside try to catch it.
  
  // Functions will try to handle exceptions by default, which can affect performance somewhat.
  // You can define function as noexcept to make them not throw errors.
  void my_function() noexcept;
  ```
##### [Iterators](https://en.cppreference.com/w/cpp/iterator/begin.html) - Data containers can be looped through easily.
```cpp
std::vector<int> a;
a.begin(); // gives a iterator class that can step through sequentially from the start.
a.end(); // gives an iterator class that starts from the end.
std::sort(a.begin(), a.end()) // Gives a start and end, allows you to only send segments as well.

for(a::iterator it = a.begin(); it != a.end(); a++) { ... }
// or in modern c++ you have range-for
for(auto i : a) { }
```
- References - A reference type where you want to pass only the address and not use any movement in memory.
```cpp
int my_int;
int& a = my_int; // will store the address, but when you access it, you will get the value like a regular type, references usually arent null if used correctly.

void modify_a(int& a) {
	a = 3; // You can pass an argument as a reference and modify the source location, usually known as an out parameter
}
```
##### [Function overloading](https://en.cppreference.com/w/cpp/language/overload_resolution.html) - Use the same function name, but can make new functions with other arguments and types.
```cpp
	void my_func();
	void my_func(int a);
	void my_func(int a, float b);
	void my_func(int a, float b, double c); // You can only have a function with one matching set of argument types.
```
##### [Optional/Default arguments](https://en.cppreference.com/w/cpp/language/default_arguments.html) - Allows functions at the end have a default set value in arguments so you can skip writing them if not needed.
```cpp
  void my_func(int a, int b, int c = 30); // assigns default values that doesnt need to be added when calling.
  my_func(10, 10); // 
  void my_func(int a, int b, int c = 30, int c = 200); // This one would actually cause errors, 
  // its trying to match 2 inte from the call, but it doesnt know which function to choose with the optional arguments.
```
#####  [Lambda functions](https://en.cppreference.com/w/cpp/language/lambda.html#Lambda_capture) - Functions that can exist in an expressions and bodies, with the ability to grab values from outside itself.
```c
int x = 20;
// All things within [] is passed as an extra struct that follows the function around, making its size more than just a pointer
// However first example doesnt have anything, so it can be treated as a function pointer.
void (*func_a)() = []{ do_stuff(); };
// Call it like a regular function
func_a();
// Here we pass x on explicitly, they are usually known as captures (since they pass/capture them at the moment this code creates the lambda.)
auto func_b = [x](int a, int b) -> int { return a + b + c; };
// & within will pass everything with references (could be bad if passing stack variables and its stored somewhere)
auto func_c = [&](int a, int b) -> int { return a + b + c; };
// = will copy all data (allocate if neccessary)
auto my_function_d = [=](int a, int b) -> int { return a + b + c; };
// captures are a list so you can override for each variable you put in it.
[&] {};          // OK: by-reference capture default
[&, i] {};       // OK: by-reference capture, except i is captured by copy
[&, &i] {};      // Error: by-reference capture when by-reference is the default
[&, this] {};    // OK, equivalent to [&]
[&, this, i] {}; // OK, equivalent to [&, i]
[&, this, j = i] {}; // OK, equivalent to [&, j] where i is set as j

// you can treat them as variables as well.
[=, my_var = do_something()] {}; // However they are constant by default.
[=, my_var = do_something()] mutable { my_var = do_something_else(); }; // However they are constant by default, to modify the state internally, you can mark it as mutable.


// Functions have an optional syntax to make it a bit more like lambdas if needed
// This can be placed outside of function bodies, tho its highly unused.
auto my_function() -> int {

}
```
##### [Operator Overloading](https://en.cppreference.com/w/cpp/language/operators.html) - almost any math, logical, bitwise operators. type castingf and more in C++ can be its own function that gives it specific functionality.
```cpp
// placed inside classes to overrride thiers interaction between other types.
inline bool operator==(const X& lhs, const X& rhs) { return cmp(lhs,rhs) == 0; }
inline bool operator!=(const X& lhs, const X& rhs) { return cmp(lhs,rhs) != 0; }
inline bool operator< (const X& lhs, const X& rhs) { return cmp(lhs,rhs) <  0; }
inline bool operator> (const X& lhs, const X& rhs) { return cmp(lhs,rhs) >  0; }
inline bool operator<=(const X& lhs, const X& rhs) { return cmp(lhs,rhs) <= 0; }
inline bool operator>=(const X& lhs, const X& rhs) { return cmp(lhs,rhs) >= 0; }
```
##### [Classes](https://en.cppreference.com/w/cpp/language/classes.html) - Adds functions, inheritance, creation and deletion logic, and visibility protection to structures, structs can also be coded as classes.
```cpp

// Structs can inherit each other.
// you can use struct and class keywords freely, they fill the same function, 
// only difference is that the default visibility for structs is public, and for classes its private.
// But prefer to use struct for anything that doesnt use constructors / destructors incase you want it to be compatible with C
struct A { int a,b,c; };
struct B : A { int d = 10, e = 30; }; // Adding default members will automatically create a hidden constructor.

class BaseClass {
protected:
	int x, y;
	void inheritedFunction() {}
};

// Pure virtual classes are preffered since they dont actually store more data or logic
class PureVirtualClass {
public: // Known as an interface or abstract class (if not full virtual)
	virtual ~PureVirtualClass() = 0; // Has no destructor
	virtual myPureVirtualFunction() = 0; // pure virtual functions has no body, but requires any class that inherits it to make one.
}

class VirtualClass {
public:
	virtual int overridableVirtualFunction() { return 10; }
}

// C is one of the few languages that can inherit multiple classes at the same time, but its a bit costly performance wise, less predictability.
// A class acts as its own namespace as well, so any member can be referenced with ::
class MyClass final // Final indicates this class can not be inherited anymore
:  protected BaseClass, protected PureVirtualClass, VirtualClass  {
public: // Anything can see this and use it.
	// Constructors doesnt need the : after, but if you inherit
	MyClass() : BaseClass(), B(), C(), member_a(110), member_b(20) {}
	~MyClass() = default;
	
	// const function bodies makes sure no members are mutated, good get anything that just grabs or calculates a value
	int myFunction() const { return member_a; }
	int overridableVirtualFunction() override { return 20; }
	inline int myOtherFunction() {} // member functions can be inlined.
	static void MyStaticFunction(); // static members/functions makes the class act as a namespace.
	// its not connected to any existing instances of
protected: // Anything here can classes that inherits this one use, however not really relevant cause this class is final.
private:
	int member_a = 40, member_b = 50;
};

// You can declare function bodies and static variables by just using the namespace.
void MyClass::MyStaticFunction() {
	do_stuff();
}

```
#####  [Templates](https://en.cppreference.com/w/cpp/language/templates.html) - Macros on steriods, code-based macros for types, constants that can be applied to classes, function and more.
```cpp
// Templates is like adding arguments for Types
// They can be attached to classes or function to pass on types and constants.
template<typename T, size_t N = 4>
inline std::array<T, N> create_array() { return std::array<T, N>(); }

std::array<int, 4> my_array = create_array<int, 4>();

template<typename K, typename T>
class Pair {
public:
	K key;
	V value;
	// Functions in templated classes can have thier own templates.
	template<typename TypeToConvertTo>
	TypeToConvertTo try_convert() { do_stuff(); }
	
	// Variadic templates can sort of get the remaining arguments and pass them around
	template<typename T, typename... TArgs>
	V set_value(TArgs&&... args) {
		return V(std::forward(args)));
	}
};
 
```
##### STL - Standard Template Library, makes almost all code a lot more manageable and contained, some basic but important ones.
- algorithm
- streams
- shared_ptr, unique_ptr
- string, string_view
- vector, array
- map, unordered_map, flat_map
- set, unordered_set, flat_set
- function
- tuple
- variant
- optional
- list, forward_list, deque
- span, range

Some Recent features added past 10 years that alters it alot.
- For Ranges, allows to loop through iterators very easy.
- Regex - Regular Expressions - Very powerful text search and replace.
- User literals - Allows to add code for your own suffixes to string and numbers.
- Auto - No need to add types to variables, it can recognize it form the function calls (unless type cannot be deduced somehow.)
- Constexpr, consteval, constinit - Compile-time calculation and data manipulation, grows in competence over years, very powerful.
- Structured bindings - Allows picking out members of structs and classes to make it shorter to read.
- Concepts - Adds user-defined constraints for Templates to make it easier to handle complex cases.
- Enums can inherit a base type.
- Class Enums
- Decltype
- Pragma once
- Coroutines (Allows to run fork and join functions in parallel)
- Ranges & Views (Short and compact data processing)
- Modules (however its not really a stable feature yet.)

