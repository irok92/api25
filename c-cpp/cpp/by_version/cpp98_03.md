# C++98/03 Features

This document lists features from the original C++ standard (C++98) and its first revision (C++03). These form the foundation of C++.

## Core Language Features

### Basic Concepts
- [Basic concepts](../01_foundational_concepts/basic_concepts.md) - Translation phases, identifiers, main function
- [Types](../02_types_and_objects/types.md) - Fundamental types: `int`, `float`, `double`, `char`, `bool`, `void`
- [Objects](../02_types_and_objects/object.md) - Object lifetime and scope
- [Declarations and definitions](../02_types_and_objects/definitions_and_odr.md) - ODR (One Definition Rule)

### Keywords and Preprocessor
- [Keywords](../03_keywords_and_preprocessor/keywords.md) - Reserved words: `if`, `else`, `for`, `while`, `class`, `struct`, etc.
- [Preprocessor](../03_keywords_and_preprocessor/preprocessor.md) - `#include`, `#define`, `#ifdef`, `#ifndef`, `#pragma`

### Expressions and Operators
- [Expressions](../04_expressions/expressions.md) - Value categories, evaluation order
- [Operators](../04_expressions/operators.md) - Arithmetic, logical, bitwise, comparison operators
- [Conversions](../04_expressions/conversions.md) - Implicit conversions, casting

### Literals
- [Integer literals](../04_expressions/literals.md) - Decimal: `42`, Octal: `052`, Hex: `0x2A`
- [Floating-point literals](../04_expressions/literals.md) - `3.14`, `1.0e-5`
- [Character literals](../04_expressions/literals.md) - `'a'`, `'\n'`, wide char: `L'x'`
- [String literals](../04_expressions/literals.md) - `"hello"`, wide strings: `L"text"`

### Declarations
- [Storage and linkage](../05_declarations/storage_and_linkage.md) - `auto` (storage class), `static`, `extern`
- [Namespaces](../05_declarations/namespaces.md) - `namespace`, `using` directive
- [Pointers and References](../05_declarations/compound_types.md) - `T*`, `T&`
- [Arrays](../05_declarations/compound_types.md) - C-style arrays: `int arr[10]`
- [Enumerations](../05_declarations/structured_bindings_and_enumerations.md) - `enum Color { RED, GREEN, BLUE }`
- [Type aliases](../05_declarations/type_aliases.md) - `typedef int MyInt;`
- [`const` and `volatile`](../05_declarations/specifiers_and_qualifiers.md) - CV qualifiers

### Initialization
- [Initialization](../06_initialization/initialization.md) - Direct: `int x = 5;`, Copy: `int y(x);`
- [Default initialization](../06_initialization/basic_initialization_forms.md)
- [Value initialization](../06_initialization/basic_initialization_forms.md)
- [Aggregate initialization](../06_initialization/basic_initialization_forms.md) - `Point p = {1, 2};`

### Functions
- [Functions](../07_functions/functions.md) - Function declaration, definition, parameters
- [Function overloading](../07_functions/function_resolution_and_overloading.md) - Same name, different parameters
- [Default arguments](../07_functions/functions.md) - `void func(int x = 0);`
- [Inline functions](../05_declarations/specifiers_and_qualifiers.md) - `inline` specifier

### Statements
- [Conditional statements](../08_statements/conditional_statements.md) - `if`, `else`, `switch`
- [Iteration statements](../08_statements/iteration_statements.md) - `for`, `while`, `do-while`
- [Jump statements](../08_statements/jump_statements.md) - `break`, `continue`, `return`, `goto`

### Classes
- [Classes](../09_classes/classes.md) - `class` and `struct` definitions
- [Access control](../09_classes/access_control.md) - `public`, `protected`, `private`
- [Class members](../09_classes/class_members.md) - Data members, member functions
- [Constructors and destructors](../09_classes/special_member_functions.md)
- [Copy constructor](../09_classes/special_member_functions.md)
- [Copy assignment operator](../09_classes/special_member_functions.md)
- [Inheritance](../09_classes/inheritance_and_derived_classes.md) - Single and multiple inheritance
- [Virtual functions](../09_classes/inheritance_and_derived_classes.md) - Dynamic polymorphism
- [Abstract classes](../09_classes/inheritance_and_derived_classes.md) - Pure virtual functions
- [friend declaration](../09_classes/access_control.md)
- [Operator overloading](../07_functions/function_resolution_and_overloading.md)
- [Conversion functions](../09_classes/conversion_functions.md)

### Templates
- [Templates](../10_templates/templates.md) - Function and class templates
- [Template parameters](../10_templates/template_fundamentals.md) - Type and non-type parameters
- [Template specialization](../10_templates/template_specialization.md) - Full and partial
- [Template argument deduction](../10_templates/template_argument_deduction.md)

### Exceptions
- [Exception handling](../11_exceptions/exception_handling.md) - `try`, `catch`, `throw`
- [Exception specification](../11_exceptions/exception_specification.md) - `throw(Type)` (later deprecated)
- [Stack unwinding](../11_exceptions/exceptions.md)

### Type System
- [Name lookup](../02_types_and_objects/name_lookup.md) - Unqualified, qualified, ADL
- [Overload resolution](../07_functions/function_resolution_and_overloading.md)
- [Template argument deduction](../10_templates/template_argument_deduction.md)

## Standard Library Highlights

While this document focuses on language features, C++98/03 included:
- Containers: `vector`, `list`, `map`, `set`, `deque`, etc.
- Algorithms: `sort`, `find`, `transform`, etc.
- Iterators
- String class: `std::string`
- Streams: `iostream`, `fstream`, `sstream`

## Notable Limitations (Addressed in Later Standards)

- No move semantics (C++11)
- No lambda expressions (C++11)
- No `auto` type deduction (C++11)
- No range-based for loops (C++11)
- No uniform initialization `{}` (C++11)
- No `nullptr` (C++11 - had to use `NULL` or `0`)
- No rvalue references (C++11)
- Template metaprogramming was cumbersome
- No variadic templates (C++11)

## Comprehensive Example

This example demonstrates core C++98/03 features including [classes](#classes), [templates](#templates), [inheritance](#classes), [exceptions](#exceptions), [namespaces](../05_declarations/namespaces.md), and [operator overloading](../07_functions/function_resolution_and_overloading.md).

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
#include <algorithm>

// ============================================================================
// NAMESPACE: Organize related code
// ============================================================================
namespace ShapeLibrary {

// ============================================================================
// ABSTRACT BASE CLASS: Demonstrates polymorphism with virtual functions
// ============================================================================
class Shape {
protected:
    std::string name;
    
public:
    // Constructor with default parameter
    Shape(const std::string& n = "Shape") : name(n) {}
    
    // Virtual destructor (essential for polymorphism)
    virtual ~Shape() {}
    
    // Pure virtual function (abstract method)
    virtual double area() const = 0;
    
    // Virtual function with default implementation
    virtual void draw() const {
        std::cout << "Drawing " << name << " with area: " << area() << std::endl;
    }
    
    // Const member function
    std::string getName() const { return name; }
};

// ============================================================================
// DERIVED CLASSES: Inheritance and method overriding
// ============================================================================
class Circle : public Shape {
private:
    double radius;
    
public:
    // Constructor with member initializer list
    Circle(double r) : Shape("Circle"), radius(r) {
        if (r <= 0) {
            // Exception handling: throw on invalid input
            throw std::invalid_argument("Radius must be positive");
        }
    }
    
    // Override pure virtual function
    double area() const {
        return 3.14159265358979323846 * radius * radius;
    }
    
    // Getter (accessor)
    double getRadius() const { return radius; }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : Shape("Rectangle"), width(w), height(h) {
        if (w <= 0 || h <= 0) {
            throw std::invalid_argument("Dimensions must be positive");
        }
    }
    
    double area() const {
        return width * height;
    }
    
    double getWidth() const { return width; }
    double getHeight() const { return height; }
};

// ============================================================================
// TEMPLATE CLASS: Generic programming
// ============================================================================
template<typename T>
class Container {
private:
    std::vector<T> items;
    
public:
    // Add item
    void add(const T& item) {
        items.push_back(item);
    }
    
    // Get item by index (with bounds checking)
    const T& get(size_t index) const {
        if (index >= items.size()) {
            throw std::out_of_range("Index out of bounds");
        }
        return items[index];
    }
    
    // Get size
    size_t size() const {
        return items.size();
    }
    
    // Iterator access (for standard algorithms)
    typename std::vector<T>::iterator begin() { return items.begin(); }
    typename std::vector<T>::iterator end() { return items.end(); }
    typename std::vector<T>::const_iterator begin() const { return items.begin(); }
    typename std::vector<T>::const_iterator end() const { return items.end(); }
};

// ============================================================================
// TEMPLATE FUNCTION: Generic algorithm
// ============================================================================
template<typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

// Template specialization for C-strings
template<>
const char* maximum<const char*>(const char* a, const char* b) {
    return (std::strcmp(a, b) > 0) ? a : b;
}

// ============================================================================
// FUNCTOR (Function Object): For use with algorithms
// ============================================================================
class AreaComparator {
public:
    // operator() makes this a function object
    bool operator()(const Shape* a, const Shape* b) const {
        return a->area() < b->area();
    }
};

} // namespace ShapeLibrary

// ============================================================================
// MAIN: Demonstrate all features
// ============================================================================
int main() {
    using namespace ShapeLibrary;
    
    try {
        // ====================================================================
        // DYNAMIC POLYMORPHISM: Base class pointers to derived objects
        // ====================================================================
        std::vector<Shape*> shapes;
        
        // Create shapes on the heap (manual memory management in C++98)
        shapes.push_back(new Circle(5.0));
        shapes.push_back(new Rectangle(4.0, 6.0));
        shapes.push_back(new Circle(3.0));
        
        std::cout << "=== All Shapes ===" << std::endl;
        // Traditional for loop (no range-based for in C++98)
        for (size_t i = 0; i < shapes.size(); ++i) {
            shapes[i]->draw();  // Virtual function call (dynamic dispatch)
        }
        
        // ====================================================================
        // STANDARD ALGORITHMS: Using STL
        // ====================================================================
        std::cout << "\n=== Sorted by Area ===" << std::endl;
        std::sort(shapes.begin(), shapes.end(), AreaComparator());
        
        for (size_t i = 0; i < shapes.size(); ++i) {
            std::cout << shapes[i]->getName() << ": " 
                      << shapes[i]->area() << std::endl;
        }
        
        // ====================================================================
        // TEMPLATE USAGE: Generic container
        // ====================================================================
        std::cout << "\n=== Template Container ===" << std::endl;
        Container<int> numbers;
        numbers.add(42);
        numbers.add(17);
        numbers.add(99);
        
        for (size_t i = 0; i < numbers.size(); ++i) {
            std::cout << "Number " << i << ": " << numbers.get(i) << std::endl;
        }
        
        // ====================================================================
        // TEMPLATE FUNCTION: Generic algorithm
        // ====================================================================
        std::cout << "\n=== Template Functions ===" << std::endl;
        std::cout << "Max(10, 20): " << maximum(10, 20) << std::endl;
        std::cout << "Max(3.14, 2.71): " << maximum(3.14, 2.71) << std::endl;
        std::cout << "Max(\"abc\", \"xyz\"): " << maximum("abc", "xyz") << std::endl;
        
        // ====================================================================
        // CLEANUP: Manual memory management (no smart pointers in C++98)
        // ====================================================================
        for (size_t i = 0; i < shapes.size(); ++i) {
            delete shapes[i];  // Must manually delete to avoid memory leaks
        }
        shapes.clear();
        
    } catch (const std::exception& e) {
        // EXCEPTION HANDLING: Catch by const reference
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;  // Success
}
```

**Key C++98/03 Patterns Demonstrated:**

1. **Manual Memory Management**: Using `new`/`delete` (improved with smart pointers in C++11)
2. **Traditional For Loops**: Using indices (range-based for added in C++11)
3. **`NULL` for pointers**: Not shown but would use `NULL` or `0` instead of `nullptr` (C++11)
4. **Verbose Type Names**: Full iterator types like `std::vector<T>::iterator` (auto in C++11)
5. **Function Objects**: Creating functor classes (lambdas added in C++11)
6. **Copy Semantics**: All passing by value means copying (move semantics in C++11)
